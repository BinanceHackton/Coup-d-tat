const { resolve } = require('path');
const readline = require('readline');
const r1 = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

//사용자 입력 받기 함수
function getUserInput(question) {
    return new Promise((resolve) => {
        r1.question(question, (answer) => {
            resolve(answer);
        });        
    });
};

// 카드 객체 생성 함수
function createCard(name) {
  return {
    name,
    doesBeat: (opponent) => {
      // 게임 규칙에 따라 카드 간 승패를 계산하여 true/false를 반환
      switch (name) {
        case '왕':
          return opponent.name === '귀족' || opponent.name === '평민';
        case '귀족':
          return opponent.name === '기사' || opponent.name === '평민';
        case '기사':
          return opponent.name === '왕' || opponent.name === '귀족';
        case '평민':
          return false;
      }
    },
  };
}


// 현재 라운드와 게임 점수를 출력하는 함수
function printRoundAndScores(round, userScore, opponentScore) {
    console.log(`\n라운드 ${round}`);
    console.log(`현재 스코어 - 플레이어 1: ${userScore}, 플레이어 2: ${opponentScore}`);
  }

//게임 로직
(async () => {
    const totalRounds = 9; //게임 총 라운드
    const cardCounts = { 왕: 3, 귀족: 2, 기사: 3, 평민: 2}; // 각 카드 종류별 장수

    //플레이어가 가지는 카드 덱 생성
    const userDeck = distributeCards(cardCounts);
    const opponentDeck = distributeCards(cardCounts);

    let userScore = 0; // 플레이어 1의 점수
    let opponentScore = 0; //플레이어 2의 점수

    // 총 라운드 수 만큼 게임 실행
    for (let round = 1; round <= totalRounds; round++) {
        console.log('라운드 ${round}');

        //사용자가 선택한 카드 
        const userCardIndex = await getUserInput('플레이어 1의 카드를 선택하세요 (0-왕, 1-귀족, 2-기사, 3-평민): ');
        const userCard = userDeck.splice(userCardIndex, 1)[0]; //선택한 카드를 덱에서 제거하고 저장

        //상대방이 선택한 카드
        const opponentCardIndex = await getUserInput('플레이어 2의 카드를 선택하세요 (0-왕, 1-귀족, 2-기사, 3-평민): ');
        const opponentCard = opponentDeck.splice(opponentCardIndex, 1)[0]; // 선택한 카드를 덱에서 제거하고 저장

        console.log('플레이어 1의 카드: ${userCard.name}');
        console.log('플레이어 2의 카드: ${opponentCard.name}');
        
        // 승패 결과 계산
        if (userCard.doesBeat(opponentCard)) {
            console.log('플레이어 1 승리!');
            userScore += userCard.name === '평민' && opponentCard.name === '왕' ? 2 : 1; //특정 상황에서 추가 점수 부여
        } else if (opponentCard.doedBeat(userCard)) {
            console.log('플레이어 2 승리 !');
            opponentScore += opponentCard.name === '평민' && userCard.name === '왕' ? 2 : 1; // 특정 상황에서 추가 점수 부여
        } else {
            console.log('무승부!');
        }

        console.log('현재 스코어 - 플레이어 1: ${userScore}, 플레이어 2: ${opponentScore}\n');
        }   

        // 최종 결과 출력 
        console.log('게임이 종료되었습니다.');
        if (userScore > opponentScore) {
            console.log ('플레이어 1이 이겼습니다!');
        } else if (userScore < opponentScore) {
            console.log ('플레이어 2가 이겼습니다!');
        } else {
            console.log('무승부입니다!');
        }

        r1.close();
})();


// 사용자와 상대방에게 카드를 공평하게 분배하는 함수
function distributeCards(cardCounts) {
    const deck = []; //덱 생성

    // 각 카드 이름과 개수에 대해 반복
    for (const [cardName, count] of Object.entries(cardCounts)) {
        // 카드 개수만큼 반복
        for (let i = 1; i <= count; i++) {
            // 카드 객체 생성
            const card = createCard(cardName);
            // 덱에 카드 추가
            deck.push(card);
        }
    }

    // 완성된 덱 반환
    return deck;
}

// 카드 객체 생성 함수
function createCard(name) {
    return {
      name,
      doesBeat: (opponent) => {
        // 게임 규칙에 따라 카드 간 승패를 계산하여 true/false를 반환
        switch (name) {
          case '왕':
            return opponent.name === '귀족' || opponent.name === '평민';
          case '귀족':
            return opponent.name === '기사' || opponent.name === '평민';
          case '기사':
            return opponent.name === '왕' || opponent.name === '귀족';
          case '평민':
            return false;
        }
      },
    };
  }

